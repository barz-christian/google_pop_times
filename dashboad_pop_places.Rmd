---
title: "Googles popular places for Pankow"
author: "Christian Barz"
date: "created: 2021-07-28, reviewed: `r lubridate::today()`"
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    social: menu
    self_contained: false
    keep_md: true
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width=12, fig.height=8)
library(pacman)
p_load(flexdashboard,
       dplyr,
       ggplot2,
       leaflet,
       shiny,
       DT)
```


```{r load data, include=FALSE}
# load data
    df_raw <- read.csv("./data/pop_times.csv")

    df_wide <- read.csv("./data/pop_times_pivot.csv") %>%
        mutate(location = as.factor(location))
    
    # prepare data
    
    df_raw <- df_raw %>%
      mutate(time_spendt = if_else(is.na(time_spendt), "", time_spendt)) %>%
      mutate(Zeit = lubridate::as_datetime(Zeit))
    

    
    
    df_long <- df_raw %>%
        select(location, day_of_week , hour, 
               popularity, current_pop,time_spendt) %>%
        mutate(location = as.factor(location),
               day_of_week  = as.factor(day_of_week))
        
    locations <- unique(df_long$location)
```


### Remark on UI


Das ist ein Vorschlag **bitte Wünsche äußern!** oder **Probleme benennen, die ihr bei der Organisation habt**.

Ich bitte das springen zwischen deutsch und englisch sowie Rechtschreibfehler zu
entschuldigen. Hintergrund das Erstellen von Texten (wie diesem) ist zeitaufwendig
daher fokusiere ich mich auf das was ich spontan für relevant halte (und spontan denke ich ggf. gerade englisch). Wenn dies ein Problem ist einfach sagen und ich
passe das entsprechend an.

#### Zur Bedienung:

- click on the tabs to see a differnt table of the data
- you can filter the tables by clicking on a box below a column name
- you can sort a column by clicking on an arrow behind a column name

#### Bemerkung:

Da ich noch nicht die Schnittstelle von Google wirklich gut verstanden habe,
muß ich an ein paar Stellen auf weniger gute Lösungen zurückgreifen.

Im Moment wird jeder Ort identifiziert durch seinen Namen und seine Addresse.
Das wird bspw. bei Supermärkten ein Problem, da deren Name "REWE" lautet.
Ferner kann zur Zeit auf diese Weise nicht jeder Ort abgefragt werden.

Dies ist aber behebbar.

### Display popular times long


#### Beispiel 1

*Aufgabe:* Ihr habt am Montag und Dienstag von 10-15 Uhr Zeit und wollt den besten Platz 
finden.

*Lösung:* Wähle bei `day_of_week` Montag und Dienstag aus und stelle bei `hour` den Slider auf 10-14. Anschließend sortiere `popularity` absteigend durch klicken auf den Pfeil hinter `popularity`.


```{r plot long table,eval=TRUE}
DT::datatable(df_long, 
                      filter = 'top',
                      rownames = FALSE,
                      options = list(
                          list(pageLength = 10)
                      ))
```


### Display popular times wide

Anwendungsbeispiel: Durch filtern von `hour` und `location` lassen sich 
Tage identifizieren an denen viel los ist.

```{r plot wide table,eval=TRUE}
DT::datatable(df_wide, 
              filter = 'top',
              rownames = FALSE,
              options = list(pageLength = 25)
              )
```


### Display top 5 popular times per location

Hier werden einfach für jede `Location` die Top5 bzgl. `popularity` ausgegeben,
so kann man bspw. schnell sehen, wann sich welcher Ort am meisten lohnt.

```{r plot top5 table,eval=TRUE}
df_top_5 <- df_long %>%
        arrange(desc(popularity)) %>%
        group_by(location) %>%
        slice(1:5) 

DT::datatable(df_top_5, 
                      filter = 'top',
                      rownames = FALSE,
                      options = list(pageLength = 25))
```




### map shows popularity for all places from 12:00 to 13:00


**Bemerkung:** Die Längen und Breitenangaben von Google und OpenStreetMap scheinen nicht 100%ig kompatibel zu sein. Dies kann aber mit etwas Recherche behoben werden.


```{r plot pop map,eval=TRUE}
m <- leaflet() %>%
  addTiles() 

Uhrzeit <- 12

Gruppen <- unique(df_raw$day_of_week)
for(Tag in Gruppen){
  for(x in locations){
    # get coords
    longitude <- df_raw %>%
      filter(location  == x & day_of_week == Tag) %>%
      pull(lat) %>%
      unique()
    latitude <- df_raw %>%
      filter(location  == x & day_of_week == Tag) %>%
      pull(lon) %>%
      unique()
    
    # get popularity
    popularity <- df_raw %>%
      filter(location  == x) %>%
      filter(hour == Uhrzeit & day_of_week == Tag) %>%
      pull(popularity)
    
    # extract content for markers
    content <- df_raw %>% 
      filter(location  == x) %>%
      filter(hour == Uhrzeit & day_of_week == Tag) %>%
      mutate(pop = paste("popularity is", popularity, "on", day_of_week, "at", hour)) %>%
      select(address, time_spendt, pop) %>%
      paste0(collapse = ",")
    
    # add markers to map
    m <- m %>%
      addMarkers(lng = longitude,
                 lat = latitude,
                 label = paste(x, content),
                 group = Tag
      )
  }  
}


m <- m %>%
  addLayersControl(
    baseGroups = Gruppen,
    options = layersControlOptions(collapsed = FALSE)
    )

m 
```


### map current popularity (Datenherhebungszeit: `r unique(df_raw$Zeit)`)

Zeigt die derzeitige Popularität der Plätze, wobei je nach Popularität die Radien der Kreise größer oder klein sind.

Achtung: Im Moment greift das Dashboard auf einen gespeicherten Datensatz zurück. (klar ich schicke es euch ja auch offline) Es kann aber auch in der GoogleCloud gehostet werden und dort würden beim Aufrufen der website, live die Daten abgefragt werden. (wäre das interessant?)


**Anwendungsbeispiel**

Spontan die populärsten Orte finden und mit dem Maßband (icon unten links) die Wegstrecke abschätzen.


```{r plot current pop map,eval=TRUE}
heute <- unique(df_raw$Zeit)
Tag <- lubridate::wday(heute, label = TRUE, abbr = FALSE)
Uhrzeit <- lubridate::hour(heute)

df_raw %>%
  filter(hour == Uhrzeit & day_of_week == Tag) %>%
  leaflet() %>%
  addTiles() %>%
  addCircleMarkers(lat = ~lon, lng = ~lat,
                   radius = ~(current_pop/10),
                   opacity = ~current_pop,
                   popup = ~paste(location, "current popularity is:", current_pop),
                   ) %>%
    addMeasure(
    position = "bottomleft",
    primaryLengthUnit = "meters",
    primaryAreaUnit = "sqmeters",
    activeColor = "#3D535D",
    completedColor = "#7D4479")

```


### Plots for popular places



```{r plot pop map2,eval=TRUE}
m <- leaflet() %>%
  addTiles() 

Uhrzeit <- 12

Gruppen <- unique(df_raw$day_of_week)
for(Tag in Gruppen){
  for(x in locations){
    # get coords
    longitude <- df_raw %>%
      filter(location  == x & day_of_week == Tag) %>%
      pull(lat) %>%
      unique()
    latitude <- df_raw %>%
      filter(location  == x & day_of_week == Tag) %>%
      pull(lon) %>%
      unique()
    
    # get popularity
    popularity <- df_raw %>%
      filter(location  == x) %>%
      filter(hour == Uhrzeit & day_of_week == Tag) %>%
      pull(popularity)
    
    # extract content for markers
    content <- df_raw %>% 
      filter(location  == x) %>%
      filter(hour == Uhrzeit & day_of_week == Tag) %>%
      mutate(pop = paste("popularity is", popularity, "on", day_of_week, "at", hour)) %>%
      select(address, time_spendt, pop) %>%
      paste0(collapse = ",")
    
    # add markers to map
    m <- m %>%
      addMarkers(lng = longitude,
                 lat = latitude,
                 label = paste(x, content),
                 group = Tag
      )
  }  
}


m <- m %>%
  addLayersControl(
    baseGroups = Gruppen,
    options = layersControlOptions(collapsed = FALSE)
    )

m 
```
***

Die untere Graphik zeigt wie sich die Popularität am gewählten Ort über die Wochentage und Uhrzeiten verteilt.

Bitte wählen Sie ihren Ort im drop down menu `Location` aus:

```{r shiny module for analytic plots}
# define it in an extra R-Skript

# UI function
worldPhonesUI <- function(id) {
  ns <- NS(id)
  fillCol(height = 600, flex = c(NA, 1), 
    inputPanel(
      selectInput(ns("region"), "Location:", choices = locations)
    ),
    plotOutput(ns("phonePlot"), height = "100%")
  )
}

# Server function
worldPhones <- function(input, output, session) {
  output$phonePlot <- renderPlot({
    x <- input$region
    
    p <- df_long %>%
      filter(location == x) %>%
      ggplot(aes(x = hour, y = popularity,
                 colour = day_of_week)) + 
      geom_point() + 
      labs(title = paste("Popularität in der Woche am Ort:", x))
    
    p
    })
}
```

```{r}
# Include the module
worldPhonesUI("location")
callModule(worldPhones, "location")
```



