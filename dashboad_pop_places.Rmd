---
title: "Googles popular places for Pankow"
author: "Christian Barz"
date: "created: 2021-07-28, reviewed: `r lubridate::today()`"
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    social: menu
    self_contained: false
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width=12, fig.height=8)
library(pacman)
p_load(flexdashboard,
       dplyr,
       ggplot2,
       leaflet,
       DT)
```


```{r load data, include=FALSE}
# load data
    df_raw <- read.csv("./data/pop_times.csv")

    df_wide <- read.csv("./data/pop_times_pivot.csv") %>%
        mutate(location = as.factor(location))
    
    # prepare data
    
    df_raw <- df_raw %>%
      mutate(time_spendt = if_else(is.na(time_spendt), "", time_spendt)) %>%
      mutate(Zeit = lubridate::as_datetime(Zeit))
    

    
    
    df_long <- df_raw %>%
        select(location, day_of_week , hour, 
               popularity, current_pop,time_spendt) %>%
        mutate(location = as.factor(location),
               day_of_week  = as.factor(day_of_week))
        
    locations <- unique(df_long$location)
    
    df_top_5 <- df_long %>%
        arrange(desc(popularity)) %>%
        group_by(location) %>%
        slice(1:5) 
```


### Remark on UI


Das ist ein Vorschlag **bitte Wünsche äußern!** oder **Probleme benennen, die ihr bei der Organisation habt**.

Ich bitte das springen zwischen deutsch und englisch sowie Rechtschreibfehler zu
entschuldigen. Hintergrund das Erstellen von Texten (wie diesem) ist zeitaufwendig
daher fokusiere ich mich auf das was ich spontan für relevant halte (und spontan denke ich ggf. gerade englisch). Wenn dies ein Problem ist einfach sagen und ich
passe das entsprechend an.

#### Zur Bedienung:

- click on the tabs to see a differnt table of the data
- you can filter the tables by clicking on a box below a column name
- you can sort a column by clicking on an arrow behind a column name

#### Bemerkung:

Da ich noch nicht die Schnittstelle von Google wirklich gut verstanden habe,
muß ich an ein paar Stellen auf weniger gute Lösungen zurückgreifen.

Im Moment wird jeder Ort identifiziert durch seinen Namen und seine Addresse.
Das wird bspw. bei Supermärkten ein Problem, da deren Name "REWE" lautet.
Ferner kann zur Zeit auf diese Weise nicht jeder Ort abgefragt werden.

Dies ist aber behebbar.

### Display popular times long


#### Beispiel 1

*Aufgabe:* Ihr habt am Montag und Dienstag von 10-15 Uhr Zeit und wollt den besten Platz 
finden.

*Lösung:* Wähle bei `day_of_week` Montag und Dienstag aus und stelle bei `hour` den Slider auf 10-14. Anschließend sortiere `popularity` absteigend durch klicken auf den Pfeil hinter `popularity`.


```{r}
DT::datatable(df_long, 
                      filter = 'top',
                      rownames = FALSE,
                      options = list(
                          list(pageLength = 25),
                          rowCallback = JS(
                              'function(row, data) {',
                              '$("td", row).each(function(i) {',
                              'if (i == 0) return; // first column is row names',
                              'if (parseFloat(data[i]) >= 50.0)',
                              '$(this).css("color", "red");',
                              '});',
                              '}'))
                      )
```


### Display popular times wide

Anwendungsbeispiel: Durch filtern von `hour` und `location` lassen sich 
Tage identifizieren an denen viel los ist.
Sobald die Popularity größer als 50 ist, wird sie rot markiert.

```{r}
DT::datatable(df_wide, 
              filter = 'top',
              rownames = FALSE,
              options = list(pageLength = 25)
              )
```


### Display top 5 popular times per location

Hier werden einfach für jede `Location` die Top5 bzgl. `popularity` ausgegeben,
so kann man bspw. schnell sehen, wann sich welcher Ort am meisten lohnt.

```{r}
DT::datatable(df_top_5, 
                      filter = 'top',
                      rownames = FALSE,
                      options = list(pageLength = 25))
```




### map shows popularity for all places from 12:00 to 13:00


**Bemerkung:** Die Längen und Breitenangaben von Google und OpenStreetMap scheinen nicht 100%ig kompatibel zu sein. Dies kann aber mit etwas Recherche behoben werden.


```{r}
m <- leaflet() %>%
  addTiles() 

Uhrzeit <- 12

Gruppen <- unique(df_raw$day_of_week)
for(Tag in Gruppen){
  for(x in locations){
    # get coords
    longitude <- df_raw %>%
      filter(location  == x & day_of_week == Tag) %>%
      pull(lat) %>%
      unique()
    latitude <- df_raw %>%
      filter(location  == x & day_of_week == Tag) %>%
      pull(lon) %>%
      unique()
    
    # get popularity
    popularity <- df_raw %>%
      filter(location  == x) %>%
      filter(hour == Uhrzeit & day_of_week == Tag) %>%
      pull(popularity)
    
    # extract content for markers
    content <- df_raw %>% 
      filter(location  == x) %>%
      filter(hour == Uhrzeit & day_of_week == Tag) %>%
      mutate(pop = paste("popularity is", popularity, "on", day_of_week, "at", hour)) %>%
      select(address, time_spendt, pop) %>%
      paste0(collapse = ",")
    
    # add markers to map
    m <- m %>%
      addMarkers(lng = longitude,
                 lat = latitude,
                 label = paste(x, content),
                 group = Tag
      )
  }  
}


m <- m %>%
  addLayersControl(
    baseGroups = Gruppen,
    options = layersControlOptions(collapsed = FALSE)
    )

m 
```


### map current popularity (Datenherhebungszeit: `r unique(df_raw$Zeit)`)

Zeigt die derzeitige Popularität der Plätze, wobei je nach Popularität die Radien der Kreise größer oder klein sind.

Achtung: Im Moment greift das Dashboard auf einen gespeicherten Datensatz zurück. (klar ich schicke es euch ja auch offline) Es kann aber auch in der GoogleCloud gehostet werden und dort würden beim Aufrufen der website, live die Daten abgefragt werden. (wäre das interessant?)


**Anwendungsbeispiel**

Spontan die populärsten Orte finden und mit dem Maßband (icon unten links) die Wegstrecke abschätzen.


```{r}
heute <- unique(df_raw$Zeit)
Tag <- lubridate::wday(heute, label = TRUE, abbr = FALSE)
Uhrzeit <- lubridate::hour(heute)

df_raw %>%
  filter(hour == Uhrzeit & day_of_week == Tag) %>%
  leaflet() %>%
  addTiles() %>%
  addCircleMarkers(lat = ~lon, lng = ~lat,
                   radius = ~(current_pop/10),
                   opacity = ~current_pop,
                   popup = ~paste(location, "current popularity is:", current_pop),
                   ) %>%
    addMeasure(
    position = "bottomleft",
    primaryLengthUnit = "meters",
    primaryAreaUnit = "sqmeters",
    activeColor = "#3D535D",
    completedColor = "#7D4479")

```


### Plots for popular places

work in progress, ich will nur zeigen, dass sich die Daten auch visualisieren lassen.

Bspw. könnte hier ein interaktiver button hin, damit man sich eine location
aussucht. Dafür fehlte mir die Zeit.

```{r}
plots <- lapply(locations, function(x){
  df_long %>%
  filter(location == x) %>%
  ggplot(aes(x = hour, y = popularity,
             colour = day_of_week)) + geom_point() + labs(title = paste("location:", x))
})
plots[[1]]
plots[[2]]
plots[[3]]
plots[[4]]
plots[[5]]
plots[[6]]
plots[[7]]
plots[[8]]
plots[[9]]
plots[[10]]
```

